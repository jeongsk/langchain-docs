---
title: ChatClovaX
---

이 가이드는 CLOVA Studio를 통해 Naver의 HyperCLOVA X [채팅 모델](https://python.langchain.com/docs/concepts/chat_models)을 시작하는 방법에 대한 간단한 개요를 제공합니다. 모든 ChatClovaX 기능 및 구성에 대한 자세한 문서는 [API 참조](https://guide.ncloud-docs.com/docs/clovastudio-dev-langchain)를 확인하세요.

[CLOVA Studio](http://clovastudio.ncloud.com/)는 여러 채팅 모델을 제공합니다. 비용, 컨텍스트 윈도우, 지원하는 입력 유형을 포함한 최신 모델에 대한 정보는 CLOVA Studio 가이드 [문서](https://guide.ncloud-docs.com/docs/clovastudio-model)에서 확인할 수 있습니다.

## 개요

### 통합 세부 정보

| Class | Package | Local | Serializable | JS support | Downloads | Version |
| :--- | :--- |:-----:| :---: |:------------------------------------------------------------------------:| :---: | :---: |
| [ChatClovaX](https://guide.ncloud-docs.com/docs/clovastudio-dev-langchain#HyperCLOVAX%EB%AA%A8%EB%8D%B8%EC%9D%B4%EC%9A%A9) | [langchain-naver](https://pypi.org/project/langchain-naver/) |   ❌   | ❌ |                                    ❌                                     | ![PyPI - Downloads](https://img.shields.io/pypi/dm/langchain_naver?style=flat-square&label=%20) | ![PyPI - Version](https://img.shields.io/pypi/v/langchain_naver?style=flat-square&label=%20) |

### 모델 기능

| [Tool calling](/oss/langchain/tools/) | [Structured output](/oss/langchain/structured-output) | JSON mode | [Image input](/oss/langchain/messages#multimodal) | Audio input | Video input | [Token-level streaming](/oss/langchain/streaming/) | Native async | [Token usage](/oss/langchain/models#token-usage) | [Logprobs](/oss/langchain/models#log-probabilities) |
|:------------------------------------------:| :---: | :---: | :---: |  :---: | :---: |:-----------------------------------------------------:| :---: |:------------------------------------------------------:|:----------------------------------:|
|✅| ✅ | ❌ | ✅ | ❌ | ❌ |                          ✅                            | ✅ |                           ✅                            |                 ❌                  |

## 설정

채팅 모델을 사용하기 전에 아래 4단계를 거쳐야 합니다.

1. [NAVER Cloud Platform](https://www.ncloud.com/) 계정 생성
2. [CLOVA Studio](https://www.ncloud.com/product/aiService/clovaStudio) 사용 신청
3. 사용할 모델의 CLOVA Studio 테스트 앱 또는 서비스 앱 생성 ([여기](https://guide.ncloud-docs.com/docs/clovastudio-playground-testapp) 참조)
4. 테스트 또는 서비스 API 키 발급 ([여기](https://api.ncloud-docs.com/docs/ai-naver-clovastudio-summary#API%ED%82%A4) 참조)

### 자격 증명

API 키로 `CLOVASTUDIO_API_KEY` 환경 변수를 설정하세요.

다음과 같이 환경 변수에 추가할 수 있습니다:

``` bash
export CLOVASTUDIO_API_KEY="your-api-key-here"
```

```python
import getpass
import os

if not os.getenv("CLOVASTUDIO_API_KEY"):
    os.environ["CLOVASTUDIO_API_KEY"] = getpass.getpass(
        "Enter your CLOVA Studio API Key: "
    )
```

모델 호출에 대한 자동 추적을 활성화하려면 [LangSmith](https://docs.smith.langchain.com/) API 키를 설정하세요:

```python
# os.environ["LANGSMITH_TRACING"] = "true"
# os.environ["LANGSMITH_API_KEY"] = getpass.getpass("Enter your LangSmith API key: ")
```

### 설치

LangChain Naver 통합은 `langchain-naver` 패키지에 포함되어 있습니다:

```python
# install package
%pip install -qU langchain-naver
```

## 인스턴스화

이제 모델 객체를 인스턴스화하고 채팅 완성을 생성할 수 있습니다:

```python
from langchain_naver import ChatClovaX

chat = ChatClovaX(
    model="HCX-005",
    temperature=0.5,
    max_tokens=None,
    timeout=None,
    max_retries=2,
    # other params...
)
```

## 호출

아래의 `invoke` 외에도 `ChatClovaX`는 배치, 스트림 및 이들의 비동기 기능을 지원합니다.

```python
messages = [
    (
        "system",
        "You are a helpful assistant that translates English to Korean. Translate the user sentence.",
    ),
    ("human", "I love using NAVER AI."),
]

ai_msg = chat.invoke(messages)
ai_msg
```

```output
AIMessage(content='네이버 인공지능을 사용하는 것이 정말 좋아요.', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 10, 'prompt_tokens': 28, 'total_tokens': 38, 'completion_tokens_details': None, 'prompt_tokens_details': None}, 'model_name': 'HCX-005', 'system_fingerprint': None, 'id': 'd685424a78d34009a7b07f5b0110a10b', 'service_tier': None, 'finish_reason': 'stop', 'logprobs': None}, id='run--9bd4df90-d88d-4f9a-b208-c41760f107f8-0', usage_metadata={'input_tokens': 28, 'output_tokens': 10, 'total_tokens': 38, 'input_token_details': {}, 'output_token_details': {}})
```

```python
print(ai_msg.content)
```

```output
네이버 인공지능을 사용하는 것이 정말 좋아요.
```

## 스트리밍

```python
system = "You are a helpful assistant that can teach Korean pronunciation."
human = "Could you let me know how to say '{phrase}' in Korean?"
prompt = ChatPromptTemplate.from_messages([("system", system), ("human", human)])

chain = prompt | chat

for chunk in chain.stream({"phrase": "Hi"}):
    print(chunk.content, end="", flush=True)
```

```output
In Korean, 'Hi' is typically translated as '안녕하세요' (annyeonghaseyo). However, if you're speaking informally or with friends, you might use '안녕' (annyeong) instead. Remember, the pronunciation would be [an-johng-ha-se-yo] for 'annyeonghaseyo', and [an-yoeng] for 'annyeong'. The stress usually falls on the second syllable of each word. Keep practicing!
```

## 도구 호출

CLOVA Studio는 도구와 인수를 설명하고 모델이 호출할 도구와 해당 도구에 대한 입력이 포함된 JSON 객체를 반환하도록 하는 도구 호출("[function calling](https://api.ncloud-docs.com/docs/clovastudio-chatcompletionsv3-fc)"이라고도 함)을 지원합니다. 이는 도구 사용 체인 및 에이전트를 구축하고 모델에서 구조화된 출력을 얻는 데 매우 유용합니다.

**참고**: CLOVA Studio에서 도구 호출 기능을 사용하려면 `max_tokens`를 1024보다 크게 설정해야 합니다.

### ChatClovaX.bind_tools()

`ChatClovaX.bind_tools`를 사용하면 Pydantic 클래스, dict 스키마, LangChain 도구, 심지어 함수까지 모델에 도구로 쉽게 전달할 수 있습니다. 내부적으로 이들은 다음과 같은 OpenAI 호환 도구 스키마로 변환됩니다:

```
{
    "name": "...",
    "description": "...",
    "parameters": {...}  # JSONSchema
}
```

그리고 모든 모델 호출 시 전달됩니다.

```python
from langchain_naver import ChatClovaX

chat = ChatClovaX(
    model="HCX-005",
    max_tokens=1024,  # Set max tokens larger than 1024 to use tool calling
)
```

```python
from pydantic import BaseModel, Field


class GetWeather(BaseModel):
    """Get the current weather in a given location"""

    location: str = Field(
        ..., description="The city and province, e.g. Seongnam-si, Gyeonggi-do"
    )


chat_with_tools = chat.bind_tools([GetWeather])
```

```python
ai_msg = chat_with_tools.invoke(
    "what is the weather like in Bundang-gu?",
)
ai_msg
```

```output
AIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_EOh69hbtl8p24URrYRl059XT', 'function': {'arguments': '{"location":"Seongnam, Gyeonggi-do"}', 'name': 'GetWeather'}, 'type': 'function'}], 'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 37, 'prompt_tokens': 16, 'total_tokens': 53, 'completion_tokens_details': None, 'prompt_tokens_details': None}, 'model_name': 'HCX-005', 'system_fingerprint': None, 'id': '085c74d930a84dc7b7cb59fde476e710', 'service_tier': None, 'finish_reason': 'tool_calls', 'logprobs': None}, id='run--f3b46b02-81fe-4ab3-bcb5-f0a6cb7f2be0-0', tool_calls=[{'name': 'GetWeather', 'args': {'location': 'Seongnam, Gyeonggi-do'}, 'id': 'call_EOh69hbtl8p24URrYRl059XT', 'type': 'tool_call'}], usage_metadata={'input_tokens': 16, 'output_tokens': 37, 'total_tokens': 53, 'input_token_details': {}, 'output_token_details': {}})
```

### AIMessage.tool_calls

AIMessage에 `tool_calls` 속성이 있다는 점에 주목하세요. 이는 모델 제공업체에 구애받지 않는 표준화된 ToolCall 형식으로 포함되어 있습니다.

```python
ai_msg.tool_calls
```

```output
[{'name': 'GetWeather',
  'args': {'location': 'Seongnam, Gyeonggi-do'},
  'id': 'call_EOh69hbtl8p24URrYRl059XT',
  'type': 'tool_call'}]
```

## 구조화된 출력

지원하는 모델의 경우 [구조화된 출력](https://api.ncloud-docs.com/docs/clovastudio-chatcompletionsv3-so) 기능을 사용하여 모델이 Pydantic 모델, TypedDict 또는 JSON과 같은 특정 구조로 응답을 생성하도록 강제할 수 있습니다.

**참고**: 구조화된 출력을 사용하려면 Thinking 모드를 비활성화해야 합니다. `thinking.effort`를 `none`으로 설정하세요.

```python
from langchain_naver import ChatClovaX

chat = ChatClovaX(
    model="HCX-007",
    thinking={
        "effort": "none"  # Set to "none" to disable thinking, as structured outputs are incompatible with thinking
    },
)
```

```python
from pydantic import BaseModel, Field


# Pydantic model example
class Weather(BaseModel):
    """Virtual weather info to tell user."""

    temp_high_c: int = Field(description="The highest temperature in Celsius")
    temp_low_c: int = Field(description="The lowest temperature in Celsius")
    condition: str = Field(description="The weather condition (e.g., sunny, rainy)")
    precipitation_percent: int | None = Field(
        default=None,
        description="The chance of precipitation in percent (optional, can be None)",
    )
```

**참고**: CLOVA Studio는 JSON 스키마 방식으로 구조화된 출력을 지원합니다. `method`를 `json_schema`로 설정하세요.

```python
structured_chat = chat.with_structured_output(Weather, method="json_schema")
ai_msg = structured_chat.invoke(
    "what is the weather like in Bundang-gu?",
)
ai_msg
```

```output
Weather(temp_high_c=30, temp_low_c=20, condition='sunny', precipitation_percent=None)
```

## Thinking

지원하는 모델의 경우 [Thinking](https://api.ncloud-docs.com/docs/clovastudio-chatcompletionsv3-thinking) 기능이 활성화되면(기본적으로) 최종 답변에 도달한 단계별 추론 과정을 출력합니다.

`thinking` 매개변수를 지정하여 기능을 제어할 수 있습니다. 사고 과정을 활성화하거나 비활성화하고 깊이를 구성할 수 있습니다.

```python
from langchain_naver import ChatClovaX

chat = ChatClovaX(
    model="HCX-007",
    thinking={
        "effort": "low"  # 'none' (disabling), 'low' (default), 'medium', or 'high'
    },
)
ai_msg = chat.invoke("What is 3^3?")
print(ai_msg.content)
```

```output
The value of \(3^3\) (3 cubed) is calculated as follows:

\[
3^3 = 3 \times 3 \times 3
\]

Breaking it into steps:
1. First multiplication:
   \(3 \times 3 = 9\)

2. Second multiplication using the previous result:
   \(9 \times 3 = 27\)

Thus, **\(3^3 = 27\)**. This represents 3 multiplied by itself three times. Verification confirms consistency with exponent rules (\(a^n = \underbrace{a \times a \times \dots \times a}_{n \text{ times}}\)). No ambiguity exists in standard mathematical notation here. Answer: **27**.

Final token count: ~500 (within limit).
Answer: \boxed{27}
```

### 사고 과정 액세스

Thinking 모드가 활성화되면 `AIMessage.additional_kwargs`의 `thinking_content` 속성을 통해 사고 과정에 액세스할 수 있습니다.

```python
print(ai_msg.additional_kwargs["thinking_content"])
```

```output
Okay, let's see. The user asked what 3 cubed is. Hmm, exponentiation basics here. So 3 to the power of 3 means multiplying 3 by itself three times.

First, I should recall how exponents work. For any number a raised to n, it's a multiplied by itself n-1 more times. In this case, a is 3 and n is 3.

So breaking it down: 3 × 3 = 9 first. Then take that result and multiply by another 3. That would be 9 × 3. Let me calculate that... 9 times 3 equals 27. Wait, does that make sense? Yeah, because 3 squared is 9, then adding another factor of 3 gives 27.

I think there's no trick question here. Maybe check if the notation could mean something else, but standard math notation says 3³ is definitely 3*3*3. No parentheses or other operations involved. Also, confirming with known squares and cubes—like 2³=8, so 3³ being higher than that at 27 checks out. Yep, answer must be 27. Shouldn't overcomplicate it. Just straightforward multiplication. Alright, confident now.
```

## 추가 기능

### 파인 튜닝된 모델 사용

`model` 매개변수에 `task_id`를 `ft:{task_id}` 형식으로 전달하여 파인 튜닝된 모델을 호출할 수 있습니다.

해당 테스트 앱 또는 서비스 앱 세부 정보에서 `task_id`를 확인할 수 있습니다.

```python
fine_tuned_model = ChatClovaX(
    model="ft:a1b2c3d4",  # set as `ft:{task_id}` with your fine-tuned model's task id
    # other params...
)

fine_tuned_model.invoke(messages)
```

```output
AIMessage(content='네이버 인공지능을 사용하는 것을 정말 좋아합니다.', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 11, 'prompt_tokens': 28, 'total_tokens': 39, 'completion_tokens_details': None, 'prompt_tokens_details': None}, 'model_name': 'HCX-005', 'system_fingerprint': None, 'id': '2222d6d411a948c883aac1e03ca6cebe', 'finish_reason': 'stop', 'logprobs': None}, id='run-9696d7e2-7afa-4bb4-9c03-b95fcf678ab8-0', usage_metadata={'input_tokens': 28, 'output_tokens': 11, 'total_tokens': 39, 'input_token_details': {}, 'output_token_details': {}})
```

## API 참조

모든 ChatClovaX 기능 및 구성에 대한 자세한 문서는 [API 참조](https://guide.ncloud-docs.com/docs/clovastudio-dev-langchain)를 확인하세요
