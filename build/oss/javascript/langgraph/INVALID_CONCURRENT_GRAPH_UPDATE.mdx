---
title: INVALID_CONCURRENT_GRAPH_UPDATE
---

import AlphaCallout from '/snippets/alpha-lg-callout.mdx';

<AlphaCallout />

LangGraph [`StateGraph`](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.state.StateGraph)가 여러 노드로부터 동시에 상태 업데이트를 받았으나, 해당 상태 속성이 이를 지원하지 않습니다.

이러한 문제는 그래프에서 [fanout](/oss/javascript/langgraph/graph-api#map-reduce-and-the-send-api)이나 다른 병렬 실행을 사용하고 있고, 다음과 같이 그래프를 정의한 경우 발생할 수 있습니다:



```typescript
import { StateGraph, Annotation, START } from "@langchain/langgraph";
import * as z from "zod";  // [!code highlight]

const State = z.object({
  someKey: z.string(),
});

const builder = new StateGraph(State)
  .addNode("node", (state) => {
    return { someKey: "some_string_value" };
  })
  .addNode("otherNode", (state) => {
    return { someKey: "some_string_value" };
  })
  .addEdge(START, "node")
  .addEdge(START, "otherNode");

const graph = builder.compile();
```




위 그래프의 노드가 `{ someKey: "some_string_value" }`를 반환하면, 이는 `someKey`의 상태 값을 `"some_string_value"`로 덮어씁니다.
그러나 단일 스텝 내에서 fanout과 같이 여러 노드가 `someKey`에 대한 값을 반환하는 경우, 내부 상태를 어떻게 업데이트해야 할지 불확실하므로 그래프는 이 오류를 발생시킵니다.


이를 해결하려면 여러 값을 결합하는 reducer를 정의할 수 있습니다:



```typescript
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({  // [!code highlight]
  someKey: z.array(z.string()).register(registry, {  // [!code highlight]
    reducer: {  // [!code highlight]
      fn: (existing, update) => existing.concat(update),  // [!code highlight]
    },
    default: () => [] as string[],
  }),
});
```


이렇게 하면 병렬로 실행되는 여러 노드에서 반환된 동일한 키를 처리하는 로직을 정의할 수 있습니다.

## 문제 해결

다음 사항이 이 오류를 해결하는 데 도움이 될 수 있습니다:

* 그래프가 노드를 병렬로 실행하는 경우, 관련 상태 키를 reducer와 함께 정의했는지 확인하세요.

---

<Callout icon="pen-to-square" iconType="regular">
  [Edit the source of this page on GitHub](https://github.com/langchain-ai/docs/edit/main/src/oss/langgraph/INVALID_CONCURRENT_GRAPH_UPDATE.mdx)
</Callout>
